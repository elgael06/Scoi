import { addIcons } from 'ionicons';
import { ICON_PATHS } from 'ionicons/icons';
import { defineCustomElements } from '@ionic/core/loader';
import { __rest } from 'tslib';
import React from 'react';
import ReactDom from 'react-dom';
import { alertController, loadingController, toastController, actionSheetController, modalController, popoverController } from '@ionic/core';
export { setupConfig } from '@ionic/core';
import { withRouter, matchPath } from 'react-router';

function attachEventProps(node, newProps, oldProps = {}) {
    const className = getClassName(node.classList, newProps, oldProps);
    if (className) {
        node.className = className;
    }
    Object.keys(newProps).forEach(name => {
        if (name === 'children' || name === 'style' || name === 'ref' || name === 'className') {
            return;
        }
        if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {
            const eventName = name.substring(2);
            const eventNameLc = eventName[0].toLowerCase() + eventName.substring(1);
            if (!isCoveredByReact(eventNameLc)) {
                syncEvent(node, eventNameLc, newProps[name]);
            }
        }
        else {
            node[name] = newProps[name];
        }
    });
}
function getClassName(classList, newProps, oldProps) {
    // map the classes to Maps for performance
    const currentClasses = arrayToMap(classList);
    const incomingPropClasses = arrayToMap(newProps.className ? newProps.className.split(' ') : []);
    const oldPropClasses = arrayToMap(oldProps.className ? oldProps.className.split(' ') : []);
    const finalClassNames = [];
    // loop through each of the current classes on the component
    // to see if it should be a part of the classNames added
    currentClasses.forEach((currentClass) => {
        if (incomingPropClasses.has(currentClass)) {
            // add it as its already included in classnames coming in from newProps
            finalClassNames.push(currentClass);
            incomingPropClasses.delete(currentClass);
        }
        else if (!oldPropClasses.has(currentClass)) {
            // add it as it has NOT been removed by user
            finalClassNames.push(currentClass);
        }
    });
    incomingPropClasses.forEach(s => finalClassNames.push(s));
    return finalClassNames.join(' ');
}
/**
 * Checks if an event is supported in the current execution environment.
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isCoveredByReact(eventNameSuffix, doc = document) {
    const eventName = 'on' + eventNameSuffix;
    let isSupported = eventName in doc;
    if (!isSupported) {
        const element = doc.createElement('div');
        element.setAttribute(eventName, 'return;');
        isSupported = typeof element[eventName] === 'function';
    }
    return isSupported;
}
function syncEvent(node, eventName, newEventHandler) {
    const eventStore = node.__events || (node.__events = {});
    const oldEventHandler = eventStore[eventName];
    // Remove old listener so they don't double up.
    if (oldEventHandler) {
        node.removeEventListener(eventName, oldEventHandler);
    }
    // Bind new listener.
    node.addEventListener(eventName, eventStore[eventName] = function handler(e) {
        newEventHandler.call(this, e);
    });
}
function arrayToMap(arr) {
    const map = new Map();
    arr.forEach((s) => map.set(s, s));
    return map;
}

const dashToPascalCase = (str) => str.toLowerCase().split('-').map(segment => segment.charAt(0).toUpperCase() + segment.slice(1)).join('');
function generateUniqueId() {
    return ([1e7].toString() + -1e3.toString() + -4e3.toString() + -8e3.toString() + -1e11.toString()).replace(/[018]/g, function (c) {
        const random = crypto.getRandomValues(new Uint8Array(1));
        return (c ^ random[0] & 15 >> c / 4).toString(16);
    });
}

function createReactComponent(tagName) {
    const displayName = dashToPascalCase(tagName);
    class ReactComponent extends React.Component {
        constructor(props) {
            super(props);
            this.componentRef = React.createRef();
        }
        static get displayName() {
            return displayName;
        }
        componentDidMount() {
            this.componentWillReceiveProps(this.props);
        }
        componentWillReceiveProps(props) {
            const node = ReactDom.findDOMNode(this);
            attachEventProps(node, props, this.props);
        }
        render() {
            const _a = this.props, { children, forwardedRef } = _a, cProps = __rest(_a, ["children", "forwardedRef"]);
            return React.createElement(tagName, Object.assign({}, cProps, { ref: forwardedRef }), children);
        }
    }
    function forwardRef(props, ref) {
        return React.createElement(ReactComponent, Object.assign({}, props, { forwardedRef: ref }));
    }
    forwardRef.displayName = displayName;
    return React.forwardRef(forwardRef);
}

// ionicons
const IonIcon = /*@__PURE__*/ createReactComponent('ion-icon');
// /*@__PURE__*/createReactComponent
const IonTabBarInner = /*@__PURE__*/ createReactComponent('ion-tab-bar');
const IonRouterOutletInner = /*@__PURE__*/ createReactComponent('ion-router-outlet');
const IonBackButtonInner = /*@__PURE__*/ createReactComponent('ion-back-button');
const IonTab = /*@__PURE__*/ createReactComponent('ion-tab');
const IonTabButton = /*@__PURE__*/ createReactComponent('ion-tab-button');
const IonAnchor = /*@__PURE__*/ createReactComponent('ion-anchor');
const IonApp = /*@__PURE__*/ createReactComponent('ion-app');
const IonAvatar = /*@__PURE__*/ createReactComponent('ion-avatar');
const IonBackdrop = /*@__PURE__*/ createReactComponent('ion-backdrop');
const IonBadge = /*@__PURE__*/ createReactComponent('ion-badge');
const IonButton = /*@__PURE__*/ createReactComponent('ion-button');
const IonButtons = /*@__PURE__*/ createReactComponent('ion-buttons');
const IonCard = /*@__PURE__*/ createReactComponent('ion-card');
const IonCardContent = /*@__PURE__*/ createReactComponent('ion-card-content');
const IonCardHeader = /*@__PURE__*/ createReactComponent('ion-card-header');
const IonCardSubtitle = /*@__PURE__*/ createReactComponent('ion-card-subtitle');
const IonCardTitle = /*@__PURE__*/ createReactComponent('ion-card-title');
const IonCheckbox = /*@__PURE__*/ createReactComponent('ion-checkbox');
const IonCol = /*@__PURE__*/ createReactComponent('ion-col');
const IonContent = /*@__PURE__*/ createReactComponent('ion-content');
const IonChip = /*@__PURE__*/ createReactComponent('ion-chip');
const IonDatetime = /*@__PURE__*/ createReactComponent('ion-datetime');
const IonFab = /*@__PURE__*/ createReactComponent('ion-fab');
const IonFabButton = /*@__PURE__*/ createReactComponent('ion-fab-button');
const IonFabList = /*@__PURE__*/ createReactComponent('ion-fab-list');
const IonFooter = /*@__PURE__*/ createReactComponent('ion-footer');
const IonGrid = /*@__PURE__*/ createReactComponent('ion-grid');
const IonHeader = /*@__PURE__*/ createReactComponent('ion-header');
const IonImg = /*@__PURE__*/ createReactComponent('ion-img');
const IonInfiniteScroll = /*@__PURE__*/ createReactComponent('ion-infinite-scroll');
const IonInput = /*@__PURE__*/ createReactComponent('ion-input');
const IonItem = /*@__PURE__*/ createReactComponent('ion-item');
const IonItemDivider = /*@__PURE__*/ createReactComponent('ion-item-divider');
const IonItemGroup = /*@__PURE__*/ createReactComponent('ion-item-group');
const IonItemOption = /*@__PURE__*/ createReactComponent('ion-item-option');
const IonItemOptions = /*@__PURE__*/ createReactComponent('ion-item-options');
const IonItemSliding = /*@__PURE__*/ createReactComponent('ion-item-sliding');
const IonLabel = /*@__PURE__*/ createReactComponent('ion-label');
const IonList = /*@__PURE__*/ createReactComponent('ion-list');
const IonListHeader = /*@__PURE__*/ createReactComponent('ion-list-header');
const IonMenu = /*@__PURE__*/ createReactComponent('ion-menu');
const IonMenuButton = /*@__PURE__*/ createReactComponent('ion-menu-button');
const IonMenuToggle = /*@__PURE__*/ createReactComponent('ion-menu-toggle');
const IonNote = /*@__PURE__*/ createReactComponent('ion-note');
const IonPicker = /*@__PURE__*/ createReactComponent('ion-picker');
const IonPickerColumn = /*@__PURE__*/ createReactComponent('ion-picker-column');
const IonNav = /*@__PURE__*/ createReactComponent('ion-nav');
const IonProgressBar = /*@__PURE__*/ createReactComponent('ion-progress-bar');
const IonRadio = /*@__PURE__*/ createReactComponent('ion-radio');
const IonRadioGroup = /*@__PURE__*/ createReactComponent('ion-radio-group');
const IonRange = /*@__PURE__*/ createReactComponent('ion-range');
const IonRefresher = /*@__PURE__*/ createReactComponent('ion-refresher');
const IonRefresherContent = /*@__PURE__*/ createReactComponent('ion-refresher-content');
const IonReorder = /*@__PURE__*/ createReactComponent('ion-reorder');
const IonReorderGroup = /*@__PURE__*/ createReactComponent('ion-reorder-group');
const IonRippleEffect = /*@__PURE__*/ createReactComponent('ion-ripple-effect');
const IonRow = /*@__PURE__*/ createReactComponent('ion-row');
const IonSearchbar = /*@__PURE__*/ createReactComponent('ion-searchbar');
const IonSegment = /*@__PURE__*/ createReactComponent('ion-segment');
const IonSegmentButton = /*@__PURE__*/ createReactComponent('ion-segment-button');
const IonSelect = /*@__PURE__*/ createReactComponent('ion-select');
const IonSelectOption = /*@__PURE__*/ createReactComponent('ion-select-option');
const IonSelectPopover = /*@__PURE__*/ createReactComponent('ion-select-popover');
const IonSkeletonText = /*@__PURE__*/ createReactComponent('ion-skeleton-text');
const IonSlide = /*@__PURE__*/ createReactComponent('ion-slide');
const IonSlides = /*@__PURE__*/ createReactComponent('ion-slides');
const IonSpinner = /*@__PURE__*/ createReactComponent('ion-spinner');
const IonSplitPane = /*@__PURE__*/ createReactComponent('ion-split-pane');
const IonText = /*@__PURE__*/ createReactComponent('ion-text');
const IonTextarea = /*@__PURE__*/ createReactComponent('ion-textarea');
const IonThumbnail = /*@__PURE__*/ createReactComponent('ion-thumbnail');
const IonTitle = /*@__PURE__*/ createReactComponent('ion-title');
const IonToggle = /*@__PURE__*/ createReactComponent('ion-toggle');
const IonToolbar = /*@__PURE__*/ createReactComponent('ion-toolbar');
const IonVirtualScroll = /*@__PURE__*/ createReactComponent('ion-virtual-scroll');

function createControllerComponent(displayName, controller) {
    const dismissEventName = `on${displayName}DidDismiss`;
    return class ReactControllerComponent extends React.Component {
        constructor(props) {
            super(props);
            this.id = generateUniqueId();
        }
        static get displayName() {
            return displayName;
        }
        async componentDidMount() {
            const { isOpen } = this.props;
            if (isOpen) {
                this.present();
            }
        }
        async componentDidUpdate(prevProps) {
            if (prevProps.isOpen !== this.props.isOpen && this.props.isOpen === true) {
                this.present(prevProps);
            }
            if (this.controller && prevProps.isOpen !== this.props.isOpen && this.props.isOpen === false) {
                await this.controller.dismiss();
            }
        }
        async present(prevProps) {
            const _a = this.props, { isOpen, onDidDismiss } = _a, cProps = __rest(_a, ["isOpen", "onDidDismiss"]);
            const elementProps = Object.assign({}, cProps, { [dismissEventName]: onDidDismiss });
            this.controller = await controller.create(Object.assign({}, elementProps));
            attachEventProps(this.controller, elementProps, prevProps);
            this.controller.present();
        }
        render() {
            return null;
        }
    };
}

const IonAlert = /*@__PURE__*/ createControllerComponent('IonAlert', alertController);

const IonLoading = /*@__PURE__*/ createControllerComponent('IonLoading', loadingController);

const IonToast = /*@__PURE__*/ createControllerComponent('IonToast', toastController);

function createOverlayComponent(displayName, controller) {
    const dismissEventName = `on${displayName}DidDismiss`;
    return class ReactOverlayComponent extends React.Component {
        constructor(props) {
            super(props);
            this.el = document.createElement('div');
        }
        static get displayName() {
            return displayName;
        }
        componentDidMount() {
            if (this.props.isOpen) {
                this.present();
            }
        }
        async componentDidUpdate(prevProps) {
            if (prevProps.isOpen !== this.props.isOpen && this.props.isOpen === true) {
                this.present(prevProps);
            }
            if (this.controller && prevProps.isOpen !== this.props.isOpen && this.props.isOpen === false) {
                await this.controller.dismiss();
            }
        }
        async present(prevProps) {
            const _a = this.props, { children, isOpen, onDidDismiss = () => { } } = _a, cProps = __rest(_a, ["children", "isOpen", "onDidDismiss"]);
            const elementProps = Object.assign({}, cProps, { [dismissEventName]: onDidDismiss });
            this.controller = await controller.create(Object.assign({}, elementProps, { component: this.el, componentProps: {} }));
            attachEventProps(this.controller, elementProps, prevProps);
            this.controller.present();
        }
        render() {
            return ReactDom.createPortal(this.props.children, this.el);
        }
    };
}

const IonActionSheet = /*@__PURE__*/ createOverlayComponent('IonActionSheet', actionSheetController);

const IonModal = /*@__PURE__*/ createOverlayComponent('IonModal', modalController);

const IonPopover = /*@__PURE__*/ createOverlayComponent('IonPopover', popoverController);

const IonPageInternal = (_a) => {
    var { children, forwardedRef, className } = _a, props = __rest(_a, ["children", "forwardedRef", "className"]);
    return (React.createElement("div", Object.assign({ className: className ? `ion-page ${className}` : 'ion-page', ref: forwardedRef }, props), children));
};
function forwardRef(props, ref) {
    return React.createElement(IonPageInternal, Object.assign({}, props, { forwardedRef: ref }));
}
forwardRef.displayName = 'IonPage';
const IonPage = /*@__PURE__*/ React.forwardRef(forwardRef);

class TabBar extends React.Component {
    constructor(props) {
        super(props);
        this.onTabButtonClick = (e) => {
            const targetUrl = (this.state.activeTab === e.detail.tab) ?
                this.state.tabs[e.detail.tab].originalHref :
                this.state.tabs[e.detail.tab].currentHref;
            this.props.history.push(targetUrl);
        };
        this.renderChild = (activeTab) => (child) => {
            if (child != null && typeof child === 'object' && child.props && child.type === IonTabButton) {
                const href = (child.props.tab === activeTab) ? this.props.location.pathname : (this.state.tabs[child.props.tab].currentHref);
                return React.cloneElement(child, {
                    href,
                    onIonTabButtonClick: this.onTabButtonClick
                });
            }
            return null;
        };
        const tabActiveUrls = {};
        React.Children.forEach(this.props.children, (child) => {
            if (child != null && typeof child === 'object' && child.props && child.type === IonTabButton) {
                tabActiveUrls[child.props.tab] = {
                    originalHref: child.props.href,
                    currentHref: child.props.href
                };
            }
        });
        this.state = {
            activeTab: null,
            tabs: tabActiveUrls
        };
    }
    static getDerivedStateFromProps(props, state) {
        const activeTab = Object.keys(state.tabs)
            .find(key => {
            const href = state.tabs[key].originalHref;
            return props.location.pathname.startsWith(href);
        });
        if (!activeTab || (activeTab === state.activeTab && state.tabs[activeTab].currentHref === props.location.pathname)) {
            return null;
        }
        return {
            activeTab,
            tabs: Object.assign({}, state.tabs, { [activeTab]: {
                    originalHref: state.tabs[activeTab].originalHref,
                    currentHref: props.location.pathname
                } })
        };
    }
    render() {
        return (React.createElement(IonTabBarInner, Object.assign({}, this.props, { selectedTab: this.state.activeTab }), React.Children.map(this.props.children, this.renderChild(this.state.activeTab))));
    }
}
const IonTabBar = /*@__PURE__*/ withRouter(TabBar);

const IonLifeCycleContext = React.createContext({
    onIonViewWillEnter: () => { },
    ionViewWillEnter: () => { },
    onIonViewDidEnter: () => { },
    ionViewDidEnter: () => { },
    onIonViewWillLeave: () => { },
    ionViewWillLeave: () => { },
    onIonViewDidLeave: () => { },
    ionViewDidLeave: () => { }
});
class DefaultIonLifeCycleContext {
    onIonViewWillEnter(callback) {
        this.ionViewWillEnterCallback = callback;
    }
    ionViewWillEnter() {
        if (this.ionViewWillEnterCallback) {
            this.ionViewWillEnterCallback();
        }
    }
    onIonViewDidEnter(callback) {
        this.ionViewDidEnterCallback = callback;
    }
    ionViewDidEnter() {
        if (this.ionViewDidEnterCallback) {
            this.ionViewDidEnterCallback();
        }
    }
    onIonViewWillLeave(callback) {
        this.ionViewWillLeaveCallback = callback;
    }
    ionViewWillLeave() {
        if (this.ionViewWillLeaveCallback) {
            this.ionViewWillLeaveCallback();
        }
    }
    onIonViewDidLeave(callback) {
        this.ionViewDidLeaveCallback = callback;
    }
    ionViewDidLeave() {
        if (this.ionViewDidLeaveCallback) {
            this.ionViewDidLeaveCallback();
        }
        this.componentCanBeDestroyed();
    }
    onComponentCanBeDestroyed(callback) {
        this.componentCanBeDestroyedCallback = callback;
    }
    componentCanBeDestroyed() {
        if (this.componentCanBeDestroyedCallback) {
            this.componentCanBeDestroyedCallback();
        }
    }
}

class StackItemInternal extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            ref: null
        };
    }
    componentDidMount() {
        const { forwardedRef, activateView } = this.props;
        this.setState({ ref: forwardedRef });
        if (forwardedRef && forwardedRef.current) {
            forwardedRef.current.addEventListener('ionViewWillEnter', this.ionViewWillEnterHandler.bind(this));
            forwardedRef.current.addEventListener('ionViewDidEnter', this.ionViewDidEnterHandler.bind(this));
            forwardedRef.current.addEventListener('ionViewWillLeave', this.ionViewWillLeaveHandler.bind(this));
            forwardedRef.current.addEventListener('ionViewDidLeave', this.ionViewDidLeaveHandler.bind(this));
            if (activateView) {
                activateView(forwardedRef.current);
            }
        }
    }
    componentWillUnmount() {
        const { forwardedRef } = this.props;
        if (forwardedRef && forwardedRef.current) {
            forwardedRef.current.removeEventListener('ionViewWillEnter', this.ionViewWillEnterHandler.bind(this));
            forwardedRef.current.removeEventListener('ionViewDidEnter', this.ionViewDidEnterHandler.bind(this));
            forwardedRef.current.removeEventListener('ionViewWillLeave', this.ionViewWillLeaveHandler.bind(this));
            forwardedRef.current.removeEventListener('ionViewDidLeave', this.ionViewDidLeaveHandler.bind(this));
        }
    }
    ionViewWillEnterHandler() {
        this.context.ionViewWillEnter();
    }
    ionViewDidEnterHandler() {
        this.context.ionViewDidEnter();
    }
    ionViewWillLeaveHandler() {
        this.context.ionViewWillLeave();
    }
    ionViewDidLeaveHandler() {
        this.context.ionViewDidLeave();
    }
    render() {
        const _a = this.props, { className, children, forwardedRef, activateView } = _a, rest = __rest(_a, ["className", "children", "forwardedRef", "activateView"]);
        const { ref } = this.state;
        return (React.createElement("div", Object.assign({ className: className ? `ion-page ${className}` : 'ion-page', ref: forwardedRef }, rest), ref && children));
    }
}
StackItemInternal.contextType = IonLifeCycleContext;
function forwardRef$1(props, ref) {
    return React.createElement(StackItemInternal, Object.assign({ forwardedRef: ref }, props));
}
forwardRef$1.displayName = 'StackItem';
const StackItem = /*@__PURE__*/ React.forwardRef(forwardRef$1);

const NavContext = /*@__PURE__*/ React.createContext({
    goBack: () => { }
});

const withIonLifeCycle = (WrappedComponent) => {
    return class IonLifeCycle extends React.Component {
        constructor(props) {
            super(props);
            this.componentRef = React.createRef();
        }
        componentDidMount() {
            this.context.onIonViewWillEnter(() => {
                if (this.componentRef.current.ionViewWillEnter) {
                    this.componentRef.current.ionViewWillEnter();
                }
            });
            this.context.onIonViewDidEnter(() => {
                if (this.componentRef.current.ionViewDidEnter) {
                    this.componentRef.current.ionViewDidEnter();
                }
            });
            this.context.onIonViewWillLeave(() => {
                if (this.componentRef.current.ionViewWillLeave) {
                    this.componentRef.current.ionViewWillLeave();
                }
            });
            this.context.onIonViewDidLeave(() => {
                if (this.componentRef.current.ionViewDidLeave) {
                    this.componentRef.current.ionViewDidLeave();
                }
            });
        }
        render() {
            return (React.createElement(IonLifeCycleContext.Consumer, null, context => {
                this.context = context;
                return (React.createElement(WrappedComponent, Object.assign({ ref: this.componentRef }, this.props)));
            }));
        }
    };
};

const useIonViewWillEnter = (callback) => {
    const value = React.useContext(IonLifeCycleContext);
    value.onIonViewWillEnter(callback);
};
const useIonViewDidEnter = (callback) => {
    const value = React.useContext(IonLifeCycleContext);
    value.onIonViewDidEnter(callback);
};
const useIonViewWillLeave = (callback) => {
    const value = React.useContext(IonLifeCycleContext);
    value.onIonViewWillLeave(callback);
};
const useIonViewDidLeave = (callback) => {
    const value = React.useContext(IonLifeCycleContext);
    value.onIonViewDidLeave(callback);
};

class StackItemManager extends React.Component {
    constructor(props) {
        super(props);
        this.ionLifeCycleContext = new DefaultIonLifeCycleContext();
        this._isMounted = false;
        this.state = {
            show: true
        };
        this.ionLifeCycleContext.onComponentCanBeDestroyed(() => {
            if (!this.props.mount) {
                /**
                 * Give child component time to finish calling its
                 * own onViewDidLeave before destroying it
                 */
                setTimeout(() => {
                    if (this._isMounted) {
                        this.setState({
                            show: false
                        });
                    }
                }, 1000);
            }
        });
    }
    componentDidMount() {
        this._isMounted = true;
    }
    componentWillUnmount() {
        this._isMounted = false;
    }
    render() {
        const { show } = this.state;
        return (React.createElement(IonLifeCycleContext.Provider, { value: this.ionLifeCycleContext }, show && this.props.children));
    }
}
// TODO: treeshake
StackItemManager.contextType = IonLifeCycleContext;

class RouterOutlet extends React.Component {
    constructor(props) {
        super(props);
        this.enteringEl = React.createRef();
        this.leavingEl = React.createRef();
        this.containerEl = React.createRef();
        this.inTransition = false;
        this.goBack = (defaultHref) => {
            const prevView = this.state.views.find(v => v.id === this.state.activeId);
            const newView = this.state.views.find(v => v.id === prevView.prevId);
            if (newView) {
                this.props.history.replace(newView.location.pathname || defaultHref);
            }
            else {
                /**
                 * find the parent view based on the defaultHref and add it
                 * to the views collection so that navigation works properly
                 */
                let element;
                let match;
                React.Children.forEach(this.props.children, (child) => {
                    if (match == null) {
                        element = child;
                        match = matchPath(defaultHref, child.props);
                    }
                });
                if (element && match) {
                    const viewId = generateUniqueId();
                    const parentView = {
                        id: viewId,
                        location: {
                            pathname: defaultHref
                        },
                        element: element,
                        match: match,
                        prevId: undefined,
                        mount: true
                    };
                    prevView.prevId = viewId;
                    this.setState({
                        views: [parentView, prevView]
                    });
                }
                this.props.history.replace(defaultHref);
            }
        };
        this.state = {
            direction: undefined,
            activeId: undefined,
            prevActiveId: undefined,
            tabActiveIds: {},
            views: []
        };
        this.activateView = this.activateView.bind(this);
    }
    static getDerivedStateFromProps(props, state) {
        const location = props.location;
        let match = null;
        let element;
        /**
         * Remove any views that have been unmounted previously
         */
        const views = state.views.filter(x => x.mount === true);
        /**
         * Get the current active view and if the path is the same then do nothing
         */
        const activeView = views.find(v => v.id === state.activeId);
        /**
         * Look at all available paths and find the one that matches
         */
        React.Children.forEach(props.children, (child) => {
            if (match == null) {
                element = child;
                match = matchPath(location.pathname, child.props);
            }
        });
        /**
         * If there are no matches then set the active view to null and exit
         */
        if (!match) {
            return {
                direction: undefined,
                activeId: undefined,
                prevActiveId: undefined
            };
        }
        /**
         * Get the active view for the tab that matches.
         * If the location matches the existing tab path then set that view as active
         */
        const id = state.tabActiveIds[match.params.tab];
        const currentActiveTabView = views.find(v => v.id === id);
        if (currentActiveTabView && currentActiveTabView.location.pathname === props.location.pathname) {
            if (currentActiveTabView.id === state.activeId) {
                /**
                 * The current tab was clicked, so do nothing
                 */
                return null;
            }
            /**
             * Activate a tab that is already in views
             */
            return {
                direction: undefined,
                activeId: currentActiveTabView.id,
                prevActiveId: state.activeId,
                views: views
            };
        }
        /**
         * If the new active view is a previous view, then animate it back in
         */
        if (activeView) {
            const prevActiveView = views.find(v => v.id === activeView.prevId);
            if (prevActiveView && activeView.match.params.tab === match.params.tab && prevActiveView.match.url === match.url) {
                return {
                    direction: 'back',
                    activeId: prevActiveView.id,
                    prevActiveId: activeView.id,
                    tabActiveIds: Object.assign({}, state.tabActiveIds, { [match.params.tab]: prevActiveView.id }),
                    views: views.map(x => {
                        if (x.id === activeView.id) {
                            return Object.assign({}, x, { mount: false });
                        }
                        return x;
                    })
                };
            }
        }
        /**
           * If the current view does not match the url, see if the view that matches the url is currently in the stack.
           * If so, show the view that matches the url and remove the current view.
           */
        if (currentActiveTabView && currentActiveTabView.location.pathname !== props.location.pathname) {
            const view = views.find(x => x.location.pathname == props.location.pathname);
            if (view && view.id === currentActiveTabView.prevId) {
                return {
                    direction: undefined,
                    activeId: view.id,
                    prevActiveId: undefined,
                    views: views.filter(x => x.id !== currentActiveTabView.id),
                    tabActiveIds: Object.assign({}, state.tabActiveIds, { [match.params.tab]: view.id }),
                };
            }
        }
        /**
         * Else add this new view to the stack
         */
        const viewId = generateUniqueId();
        const newState = {
            direction: (state.tabActiveIds[match.params.tab]) ? 'forward' : undefined,
            activeId: viewId,
            prevActiveId: state.tabActiveIds[match.params.tab] || state.activeId,
            tabActiveIds: Object.assign({}, state.tabActiveIds, { [match.params.tab]: viewId }),
            views: views.concat({
                id: viewId,
                location,
                match,
                element,
                prevId: state.tabActiveIds[match.params.tab],
                mount: true
            })
        };
        return newState;
    }
    renderChild(item) {
        const component = React.cloneElement(item.element, {
            location: item.location,
            computedMatch: item.match
        });
        return component;
    }
    activateView(el) {
        /**
         * Gets called from StackItem to initialize a new view
         */
        if (!this.state.direction) {
            const leavingEl = (this.leavingEl.current != null) ? this.leavingEl.current : undefined;
            this.transitionView(el, leavingEl);
        }
    }
    transitionView(enteringEl, leavingEl) {
        //
        /**
         * Super hacky workaround to make sure containerEL is available
         * since activateView might be called from StackItem before IonRouterOutlet is mounted
         */
        if (this.containerEl && this.containerEl.current && this.containerEl.current.componentOnReady) {
            this.commitView(enteringEl, leavingEl);
        }
        else {
            setTimeout(() => {
                this.transitionView(enteringEl, leavingEl);
            }, 10);
        }
    }
    async commitView(enteringEl, leavingEl) {
        if (!this.inTransition) {
            this.inTransition = true;
            await this.containerEl.current.componentOnReady();
            await this.containerEl.current.commit(enteringEl, leavingEl, {
                deepWait: true,
                duration: this.state.direction === undefined ? 0 : undefined,
                direction: this.state.direction,
                showGoBack: this.state.direction === 'forward',
                progressAnimation: false
            });
            if (leavingEl) {
                /**
                 *  add hidden attributes
                */
                leavingEl.classList.add('ion-page-hidden');
                leavingEl.setAttribute('aria-hidden', 'true');
            }
            this.inTransition = false;
        }
    }
    componentDidUpdate(_prevProps, prevState) {
        /**
         * Don't transition the view if the state didn't change
         * Probably means we are still on the same view
         */
        if (prevState !== this.state) {
            const enteringEl = (this.enteringEl.current != null) ? this.enteringEl.current : undefined;
            const leavingEl = (this.leavingEl.current != null) ? this.leavingEl.current : undefined;
            this.transitionView(enteringEl, leavingEl);
        }
    }
    render() {
        return (React.createElement(IonRouterOutletInner, { ref: this.containerEl },
            React.createElement(NavContext.Provider, { value: { goBack: this.goBack } }, this.state.views.map((item) => {
                let props = {};
                if (item.id === this.state.prevActiveId) {
                    props = {
                        'ref': this.leavingEl
                    };
                }
                else if (item.id === this.state.activeId) {
                    props = {
                        'ref': this.enteringEl,
                        'className': (this.state.direction != null ? ' ion-page-invisible' : '')
                    };
                }
                else {
                    props = {
                        'aria-hidden': true,
                        'className': 'ion-page-hidden'
                    };
                }
                return (React.createElement(StackItemManager, { key: item.id, mount: item.mount },
                    React.createElement(StackItem, Object.assign({ activateView: this.activateView }, props), this.renderChild(item))));
            }))));
    }
}
const IonRouterOutlet = /*@__PURE__*/ withRouter(RouterOutlet);

const hostStyles = {
    display: 'flex',
    position: 'absolute',
    top: '0',
    left: '0',
    right: '0',
    bottom: '0',
    flexDirection: 'column',
    width: '100%',
    height: '100%',
    contain: 'layout size style'
};
const tabsInner = {
    position: 'relative',
    flex: 1,
    contain: 'layout size style'
};
class IonTabs extends React.Component {
    render() {
        let outlet;
        let tabBar;
        React.Children.forEach(this.props.children, (child) => {
            if (child == null || typeof child !== 'object' || !child.hasOwnProperty('type')) {
                return;
            }
            if (child.type === IonRouterOutlet) {
                outlet = child;
            }
            if (child.type === IonTabBar) {
                tabBar = child;
            }
        });
        return (React.createElement("div", { style: hostStyles },
            tabBar.props.slot === 'top' ? tabBar : null,
            React.createElement("div", { style: tabsInner, className: "tabs-inner" }, outlet),
            tabBar.props.slot === 'bottom' ? tabBar : null));
    }
}

class IonBackButton extends React.Component {
    constructor() {
        super(...arguments);
        this.clickButton = (e) => {
            e.stopPropagation();
            this.context.goBack(this.props.defaultHref);
        };
    }
    render() {
        return (React.createElement(IonBackButtonInner, Object.assign({ onClick: this.clickButton }, this.props)));
    }
}
IonBackButton.contextType = NavContext;

addIcons(ICON_PATHS);
defineCustomElements(window);

export { IonActionSheet, IonAlert, IonAnchor, IonApp, IonAvatar, IonBackButton, IonBackButtonInner, IonBackdrop, IonBadge, IonButton, IonButtons, IonCard, IonCardContent, IonCardHeader, IonCardSubtitle, IonCardTitle, IonCheckbox, IonChip, IonCol, IonContent, IonDatetime, IonFab, IonFabButton, IonFabList, IonFooter, IonGrid, IonHeader, IonIcon, IonImg, IonInfiniteScroll, IonInput, IonItem, IonItemDivider, IonItemGroup, IonItemOption, IonItemOptions, IonItemSliding, IonLabel, IonLifeCycleContext, IonList, IonListHeader, IonLoading, IonMenu, IonMenuButton, IonMenuToggle, IonModal, IonNav, IonNote, IonPage, IonPicker, IonPickerColumn, IonPopover, IonProgressBar, IonRadio, IonRadioGroup, IonRange, IonRefresher, IonRefresherContent, IonReorder, IonReorderGroup, IonRippleEffect, IonRouterOutlet, IonRouterOutletInner, IonRow, IonSearchbar, IonSegment, IonSegmentButton, IonSelect, IonSelectOption, IonSelectPopover, IonSkeletonText, IonSlide, IonSlides, IonSpinner, IonSplitPane, IonTab, IonTabBar, IonTabBarInner, IonTabButton, IonTabs, IonText, IonTextarea, IonThumbnail, IonTitle, IonToast, IonToggle, IonToolbar, IonVirtualScroll, useIonViewDidEnter, useIonViewDidLeave, useIonViewWillEnter, useIonViewWillLeave, withIonLifeCycle };
